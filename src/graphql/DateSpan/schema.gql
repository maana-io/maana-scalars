type DateSpan {
  id: ID!
  start: Date
  end: Date
}

input DateSpanInput {
  id: ID!
  start: Date
  end: Date
}

type Query {
  # Identity
  dateSpanIdentity(x: DateSpanInput!): DateSpan!
  dateSpanIdentityOpt(x: DateSpanInput): DateSpan

  # NONULL coercion
  dateSpanCoerceFromOpt(x: DateSpanInput): DateSpan!
  dateSpanCoerceToOpt(x: DateSpanInput!): DateSpan

  # String de/serialization
  dateSpanParse(x: String!): DateSpan!
  dateSpanToString(x: DateSpanInput!): String!

  # Lists
  dateSpanListUnion(a: [DateSpanInput!]!, b: [DateSpanInput!]!): [DateSpan!]!
  dateSpanListConcat(a: [DateSpanInput!]!, b: [DateSpanInput!]!): [DateSpan!]!
  dateSpanListReverse(x: [DateSpanInput!]!): [DateSpan!]!
  dateSpanListUnique(x: [DateSpanInput!]!): [DateSpan!]!
  dateSpanListFilterNulls(x: [DateSpanInput]): [DateSpan!]!

  # Projectors
  dateSpanProjectId(x: DateSpanInput!): ID!
  dateSpanProjectStart(x: DateSpanInput!): Date
  dateSpanProjectEnd(x: DateSpanInput!): Date

  # Default value resolution
  dateSpanValueOrDefault(
    value: DateSpanInput
    defaultValue: DateSpanInput!
  ): DateSpan!
}

type Mutation {
  # Constructors
  dateSpanConstruct(start: Date, end: Date): DateSpan!
  dateSpanConstructFromId(id: ID!): DateSpan!
}
